<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="utf-8" />
    <link rel="stylesheet" type="text/css" href="css/index.css" />
    <title></title>
</head>
<body>
    <div class="parentContainer">

    <p id="keywordList" style="display:none">
        koko hampaan puutos (KHP);
        puhkeamaton (Vaihe);
        osittain puhjennut (Vaihe);
        juuren korvaava implantti (IMP);
        hampaan juuri (JUU);
        hampaan purenta (PUR);
        hampaan siirtymät ja liikkuvuudet (SIL);
        hampaan kehityshäiriöt (KH);
        hammas ylipuhjennut (HYP);
        juurikanavanasta (JNK);
        parapulpaalinasta (PPN);
        juurikanavassa lääkeainetta (JL);
        vierasesine (VIE);
        juurentäyte apeksi 2mm (JT 1);
        juurentäyte yli apeksi (JTY);
        juurentäyte guttaperkka (GP);
        juurentäyte muu materiaali (MUU);
        hammaskohtainen proteettinen rakenne (PR);
        hammaskruunu (HAK);
        yksittäinen implanttikruunu (IKR);
        implantin peittoruuvi (IPR);
        hammas poistettava (Poista);
        furkaatioleesioaste 1 (Fur 1);
        furkaatioleesioaste 2 (Fur 2);
        furkaatioleesioaste 3 (Fur 3);
        furkaatioleesioaste 4 (Fur 4);
        |
        aktiivinen dentiinikaries (DEN);
        aktiivinen kiillekaries (KII);
        täyte, yhdistelmämuovi (MUO);
        täyte, lasi-ionomeeri (LAS);
        pinnoite, yhdistelmämuovi (PIN);
        täyte, amalgaami (AMA);
        aktiivinen pulpakaries (PUL);
        inaktiivinen kiillekaries (KII);
        täyte, väliaikainen (VÄL);
        hampaan lohkeama (LOH);
        attritio (ATR);
        abraasio (ABR);
        eroosio (ERO);
        fluoroosi (FLU);
        hypoplasia (HYP);
        hypomineralisaatio (HYM);
        värjäymä, sisäinen (VÄS);
        fraktuura (FRA);
        mikrofraktuura (MFR);
        kulumafasetti (KUF);
        saumadiskrepanssi (SDI);
        hammas pinnoitettava (Pinn.);
        täyte, keramia (KER);
        ienverenvuoto (IVV);
        biofilmi (BIO);
        supragingivaalinen hammaskivi (SPH);
        subgingivaalinen hammaskivi (SBH);
        alkava parodontiitti (APA);
        krooninen kohtalainen parodontiitti (KKP);
        pulpaperäinen parodontiitti (PPP);
        ientaskuperäinen parodontiitti (IPP)
    </p>
    <!--First Panel Start-->
    <div class="historyLog" id="historyLog">

        <div class="logStatementContainerParent">
            <h2 style="margin-left:3px">Havainnot</h2>
            <div class="logStatementContainer" id="logStatementContainer">
                <div class="logStatement" id="outputStatementTemplate">
                    <div class="logText1">
                        <h2>Tunnus</h2>
                        <p id="text1">Test statement!</p>
                    </div>
                    <div class="logText2">
                        <h2>Havainto</h2>
                        <p id="text2">Test statement!</p>
                    </div>

                    <div class="xButton" id="xButton" onclick="logRemove(this)"></div>
                    <div class="statementBall" id="statementBall"></div>
                </div>
            </div>

        </div>

        <div class="controlContainer">

            <div class="toggleButton">
                <label class="switch">
                    <input id="speechToggle" type="checkbox">
                    <span class="slider round"></span>
                </label>
                <p>Toista komento uudestaan (TTS)</p>
            </div>

            <div class="voiceContainer" id="voiceContainer">
                <button onclick="RecognizeVoice()" class="requestButton" id="requestButton">
                    <img src="images/microphone.png" class="requestButtonImage" id="requestButtonImage" />
                </button>
                <p class="stateLog" id="outputState">11 1 paikkaus</p>
            </div>

            <input class="manualInput" type="text" id="manualInput" placeholder="Kirjaa manuaalisesti..." />
            <button class="inButton" id="saveButton" onclick="save()">Tallenna</button>
            <div class="inButton">
                <label style="width:100%" id="loadButton">
                    <input id="loadButtonText" type="file" accept=".txt" onchange="load(this)" />
                    Avaa...
                </label>
            </div>
            <button class="inButton" style="display:none;" id="exportButton" onclick="exportPNG()">Tallenna .png</button>
        </div>

    </div>

    <!--Second Panel Start-->
    <div class="toothInformationContainer">

        <div class="surfaceInformationContainer">

            <h2 id="toothNumber" style="margin:0;">Hammas nro.</h2>

            <div id="firstPair" class="surfacePair">
                <h2 style="margin:0;">Kokonaisuus</h2>
                <h3 id="surface0">Hammas:</h3>
            </div>

            <h2 style="margin:0;">Pintakohtaiset havainnot</h2>

            <div class="surfacePair">
                <h2 class="surfaceID">1</h2>
                <h3 id="surface1">Pinta 1:</h3>
            </div>

            <div class="surfacePair">
                <h2 class="surfaceID">2</h2>
                <h3 id="surface2">Pinta 1:</h3>
            </div>

            <div class="surfacePair">
                <h2 class="surfaceID">3</h2>
                <h3 id="surface3">Pinta 1:</h3>
            </div>

            <div class="surfacePair">
                <h2 class="surfaceID">4</h2>
                <h3 id="surface4">Pinta 1:</h3>
            </div>

            <div class="surfacePair">
                <h2 class="surfaceID">5</h2>
                <h3 id="surface5">Pinta 1:</h3>
            </div>
        </div>

        <div class="informationContainer">
            <h3>Hammaskohtaiset havainnot</h3>
            <div class="informationContainerOverflow">
                <p id="toothSpecificObservationsList"></p>
            </div>
        </div>
        
        <div class="informationContainer">
            <h3>Pintakohtaiset havainnot</h3>
            <div class="informationContainerOverflow"> 
                <p id="surfaceSpecificObservationsList"></p>
            </div>
        </div>

    </div>
    <!--Third Panel Start-->
    <div class="teethContainer">
        <div id="teeth" class="teeth">
            <div class="line" id="verticalLine"></div>
            <p class="direction" id="oikea">oikea</p>
            <p class="direction" id="vasen">vasen</p>
            <div class="line" id="horizontalLine"></div>
        </div>
        <img src="images/mouth.png" class="teethBackground" />
        <img class="logo" id="logo" src="images/logo.png" />
    </div>
    </div>
</body>
</html>

<script>

    //Tooth Database
    var teethData = new Object();

    function CreateChart() {
        var teeth = document.getElementById("teeth");
        for (let i = 1; i <= 32; i++) {

            //Divide teeth into sectors
            let sector = Math.floor((i - 1) / 8) + 1;
            let toothNum = 8;
            if (sector % 2 == 0) {
                toothNum = (i) % 8;
                if (toothNum == 0) {
                    toothNum = 8;
                }
            }
            else {toothNum = 8 - (i-1) % 8;}

            //toothParentContainer
            let tooth = document.createElement('div');
            tooth.id = `tooth${sector}${toothNum}`;
            tooth.className = "tooth";
            teeth.appendChild(tooth);
            teethData[`${sector}${toothNum}`] = ["Ei havaintoja", "Ei havaintoja", "Ei havaintoja", "Ei havaintoja", "Ei havaintoja", "Ei havaintoja"];
            tooth.onclick = function () { DisplayData(`${sector}${toothNum}`) };

            //Position all teeth in an oval shape,
            //Oval shape is derived from 2*sqrt(1-x^2)
            var j = i;
            if (i > 16) { j -= 16; }
            var x = (j - 1) / 7.5;
            //Manually adjust teeth positions for aesthetics.
            var fineTuning = [0, 0.120, 0.21, 0.265, 0.285, 0.256, 0.17, 0.055]
            if (j < 9 || (j > 16 && j < 25)) {
                x -= fineTuning[(j % 9) - 1];
            }
            else {
                x += fineTuning[(8 - j % 9) - 1];
            }
            var y = 2 * Math.sqrt(1 - (x - 1) * (x - 1));
            y = 100 - y * 25 - 54;
            var fin = 3.6;
            if (i <= 16) {
                tooth.style.left = `${x * 100 / 2}%`;
                tooth.style.top = `${y - fin - 2}%`;
            }
            else {
                tooth.style.left = `${100 - x * 100 / 2}%`;
                tooth.style.top = `${100 - y - fin + 2}%`;
            }

            //toothTextureElement
            var toothBackground = document.createElement('div');
            toothBackground.className = "toothBackground";
            toothBackground.style.transform = `rotate(${(i - 1 - ((i > 16)?1:0) ) / 30 * 360 - 90}deg)`;
            tooth.appendChild(toothBackground);

            var toothImage = document.createElement('img');
            toothImage.className = 'toothImage';
            toothImage.style.transform = `rotate(${(i - 1 - ((i > 16) ? 1 : 0)) / 30 * 360 - 90}deg)`;
            let source = toothNum;
            toothImage.src = `images/teeth/${toothNum}.png`;
            if (toothNum == 1) {
                if (sector < 3) {
                    source = `${toothNum}_1`;
                    toothImage.src = `images/teeth/${toothNum}_1.png`;
                }
                else {
                    source = `${toothNum}_2`;
                    toothImage.src = `images/teeth/${toothNum}_2.png`;
                }
            } 
            tooth.appendChild(toothImage);

            //var tops = [50,50,0,50,100];
            //var lefts = [50,0,50,100,50];
            for (let s = 0; s < 5; s++) {
                //toothSurfaceElement
                let toothSurface = document.createElement('div');
                toothSurface.className = "toothSurface";
                toothSurface.id = `toothSurface${sector}${toothNum}${s + 1}`;
                //toothSurface.style.top = `${tops[s]}%`;
                //toothSurface.style.left = `${lefts[s]}%`;
                toothSurface.style.background = `url(../images/teeth/surfaces/${source}_${s + 1}.png)`;
                toothBackground.appendChild(toothSurface);
            }

            //toothNumber
            let toothText = document.createElement('h1');
            toothText.className = "toothText";
            toothText.innerHTML = `${sector}${toothNum}`;
            toothText.style.transform = `rotate(${180 - (i - 1 - ((i > 16) ? 1 : 0)) / 30 * 360 - 90}deg)`;
            toothBackground.appendChild(toothText);

        }
    }
    CreateChart();

    var toothKeywords = [];
    var surfaceKeywords = [];
    var keywords = [];

    //Keywords
    function fillKeywordList() {
        let list = document.getElementById('keywordList').innerHTML.split(';');
        let toothSpecific = true;
        let x = "";
        let y = "";
        for (let i = 0; i < list.length; i++) {
            if (list[i].includes('|')) {
                toothSpecific = false;
                continue;
            }
            if (toothSpecific) {
                x += list[i] + '<br>';
                toothKeywords.push(list[i]);
            }
            else {
                y += list[i] + '<br>';
                surfaceKeywords.push(list[i]);
            }
            keywords.push(list[i]);
        }
        document.getElementById("toothSpecificObservationsList").innerHTML = x;
        document.getElementById("surfaceSpecificObservationsList").innerHTML = y;
    }
    fillKeywordList();

    //Manual Input//
    var input = document.getElementById("manualInput");
    input.addEventListener("keypress", function (event) {
        if (event.key === "Enter" && input.value.length > 0) {
            event.preventDefault();
            if (input.value.length > 4) {
                Recognize(input.value.split(' '));
            }
            input.value = "";
        }
    }); 

    function SurfaceColorCodes(observation) {
        switch (observation) {
            case "terve":
                return "green";
            case "reikä":
                return "olive";
            case "paikkaus":
                return "gray";
            case "juurihoito":
                return "yellow";
            case "poisto":
                return "black";
            case "ikivihreä":
                return "lime";
            case "parodontiitti":
                return "purple";
            default:
                return "green";
        }
    }

    function toothNotFound(num) {
        let tooth = document.getElementById(`tooth${num}`);
        return tooth == null;
    }

    function InitiateCommand(num, sur, obs, add_log) {
        let surface = document.getElementById(`toothSurface${num}${sur}`);
        let observations = teethData[num];

        if (toothNotFound(num)) {
            console.log("Tooth doesn't exist");
            return;
        }
        if (surface != null && sur != 0) {
            surface.style.background = SurfaceColorCodes(obs);
            observations[sur] = obs;
            teethData[num] = observations;
        }
        else {
            sur = 0;
            observations[sur] = obs;
            teethData[num] = observations;
        }
        if (add_log) {
            Log(num, sur, obs);
        }

        DisplayData(num);
        IndicatorColor("lime");
    }

    selectedTooth = "";
    function DisplayData(toothNum) {
        if (selectedTooth.length > 0) {
            unselectTooth(selectedTooth);
        }
        selectedTooth = toothNum;
        selectTooth(selectedTooth);
        document.getElementById('toothNumber').innerHTML = `Hammas nro. ${toothNum}`;
        let observations = teethData[`${toothNum}`];
        for (let i = 0; i < 6; i++) {
            document.getElementById(`surface${i}`).innerHTML = `${observations[i]}`;
        }
    }

    function unselectTooth(num) {
        document.getElementById(`tooth${num}`).style.border = "0px";
    }

    function selectTooth(num) {
        document.getElementById(`tooth${num}`).style.border = "2px solid white";
    }



    function UpdateState(data) {
        document.getElementById("outputState").innerHTML = data;
    }

    const timing = {
        duration: 600,
        iterations: 1,
        easing: "ease-out"
    }

    var logs = [];
    //Add a log statement
    function Log(num, sur, obs) {
        let template = document.getElementById("outputStatementTemplate");
        let statement = template.cloneNode(true);
        statement.style.display = "flex";
        logs.push(`${num} ${sur} ${obs}`);
        statement.id = `statement${logs.length - 1}`;

        let statementText1 = statement.querySelector('#text1');
        statementText1.id = `text1${logs.length - 1}`;
        let statementText2 = statement.querySelector('#text2');
        statementText2.id = `text2${logs.length - 1}`;
        let xButton = statement.querySelector('#xButton');
        xButton.id = `xButton${logs.length - 1}`;
        let statementBall = statement.querySelector('#statementBall');
        statementBall.id = `statementBall${logs.length - 1}`;
        statementBall.style.background = SurfaceColorCodes(obs);

        //Surface is 0 when observation is about the tooth as a whole
        if (sur == 0) {
            statementText1.innerHTML = `${num}`;
        }
        else {
            statementText1.innerHTML = `${num} ${sur}`;
        }
        statementText2.innerHTML = obs;
        

        document.getElementById("logStatementContainer").prepend(statement);
        let children = document.getElementById("logStatementContainer").children;
        const moveDown = [
            { transform: 'translateY(-118%)' },
            { transform: 'translateY(0%)' }
        ];
        for (let i = 0; i < children.length; i++) {
            children[i].animate(moveDown, timing);
        }
    }

    //Speech Synthesis Function
    const synth = window.speechSynthesis;
    function Speech(sentence) {
        if (!document.getElementById('speechToggle').checked) { return; }
        let utterance = new SpeechSynthesisUtterance(sentence);
        utterance.lang = 'fi-FI';
        utterance.rate = 0.8;
        speechSynthesis.speak(utterance);
    }

    //All log statements must have unique id's so when deleting some, we have to account for it.
    function DefineLogID(ID, newID) {
        let statement = document.getElementById(`statement${ID}`);
        statement.id = `statement${newID}`;

        let statementText1 = document.getElementById(`text1${ID}`);
        statementText1.id = `text1${newID}`;

        let statementText2 = document.getElementById(`text2${ID}`);
        statementText2.id = `text2${newID}`;

        let xButton = document.getElementById(`xButton${ID}`);
        xButton.id = `xButton${newID}`;

        let statementBall = document.getElementById(`statementBall${ID}`);
        statementBall.id = `statementBall${newID}`;
    }

    //Remove a log statement and initiate an animation on the ones below it to move up.
    var waitForAnimation = false;
    function logRemove(xButton) {
        if (waitForAnimation) { return; }
        let ID = xButton.id.replace('xButton', '');
        let statement = document.getElementById(`statement${ID}`);
        DefineLogID(ID, 'undefined');
        const moveUp = [
            { transform: 'translateY(0%)' },
            { transform: 'translateY(-115%)' }
        ];
        let log = logs[ID];
        //All of the ones on top have an ID that is 1 smaller now, since one was deleted
        //Also animate the ones below it
        for (let i = 0; i < logs.length; i++) {
            if (i > ID) {
                DefineLogID(i, i - 1);
            }
            else if (i != ID) {
                document.getElementById(`statement${i}`).animate(moveUp, timing);
            }
        }
        //Remove log statement with ID from logs array
        logs.splice(ID, 1);
        //The most recent tooth specific command is now in effect.
        for (let i = logs.length - 1; i >= -1; i--) {
            let logSplits = log.split(' ');
            if (i == -1) {
                InitiateCommand(logSplits[0], logSplits[1], 'Ei havaintoja');
                break;
            }
            let splits = logs[i].split(' ');
            if (logs[i].includes(log.substring(0, 4))) {
                InitiateCommand(splits[0], splits[1], splits[2], false);
                break;
            }
        }
        //Fade Out animation
        const fadeOut = [
            { opacity: 1 },
            { opacity: 0 }
        ];
        const fadeTiming = {
            duration: 300,
            iterations: 1,
            easing: "ease-out"
        };
        xButton.onclick = "";
        statement.style.opacity = 0;
        statement.animate(fadeOut, fadeTiming);
        waitForAnimation = true;
        setTimeout(function () { statement.remove(); waitForAnimation = false; }, 600);
    }

    InitiateCommand('11', '1', 'poisto', true);
    InitiateCommand('11', '1', 'paikkaus', true);
    InitiateCommand('11', '1', 'paikkaus', true);
    InitiateCommand('11', '1', 'paikkaus', true);
    InitiateCommand('11', '1', 'paikkaus', true);
    InitiateCommand('11', '1', 'paikkaus', true);
    InitiateCommand('11', '5', 'poisto', true);

    function save() {
        var today = new Date();
        var dd = String(today.getDate()).padStart(2, '0');
        var mm = String(today.getMonth() + 1).padStart(2, '0');
        var yyyy = today.getFullYear();
        today = mm + '/' + dd + '/' + yyyy;
        var fileName = `DentAI-Data ${today}.txt`;
        var fileContent = "";
        for (let i = logs.length - 1; i >= 0; i--) {
            fileContent += logs[i] + "\n";
        }
        const a = document.createElement('a');
        const file = new Blob([fileContent], { type: 'text/plain' });
        a.href = URL.createObjectURL(file);
        a.download = fileName;
        a.click();
        URL.revokeObjectURL(a.href);
    }

    function resetAll() {
        for (let i = 1; i <= 4; i++) {
            for (let j = 1; j <= 8; j++) {
                for (let k = 0; k <= 5; k++) {
                    InitiateCommand(`${i}${j}`, `${k}`,'Ei havaintoja');
                }
            }
        }
        for (let i = 0; i < logs.length; i++) {
            let statement = document.getElementById(`statement${i}`);
            statement.remove();
        }
        logs.length = 0;
    }

    function load(input) {
        let file = input.files[0];
        input.value = null;
        let reader = new FileReader();
        let content = "";
        reader.onload = function (event) {
            content = event.target.result;
            if (content.length < 2) { return; }
            resetAll();
            let splits = content.split('\n');
            for (let i = splits.length - 2; i >= 0; i--) {
                console.log(splits);
                console.log(splits[i].substring(0, 2), splits[i].substring(3, 4), splits[i].substring(5));
                InitiateCommand(splits[i].substring(0, 2), splits[i].substring(3, 4), splits[i].substring(5), true);
            }
        }
        reader.readAsText(file);
    }

    function exportPNG() {

    }

    function IndicatorColor(color) {
        document.getElementById("voiceContainer").style.borderColor = color;
    }

    const levenshteinDistance = (s, t) => {
        if (!s.length) return t.length;
        if (!t.length) return s.length;
        const arr = [];
        for (let i = 0; i <= t.length; i++) {
            arr[i] = [i];
            for (let j = 1; j <= s.length; j++) {
                arr[i][j] =
                    i === 0
                        ? j
                        : Math.min(
                            arr[i - 1][j] + 1,
                            arr[i][j - 1] + 1,
                            arr[i - 1][j - 1] + (s[j - 1] === t[i - 1] ? 0 : 1)
                        );
            }
        }
        return arr[t.length][s.length];
    };

    function specialExceptions(word) {
        switch (word) {
            case "parapulpaalinasta":
                return "parabullpauliinasta";
            default:
                return word;
        }
    }

    function ApproximateKeyword(obs) {
        let possibilities = [];
        let lobs = obs.toLowerCase();
        //Retrieve all possible matches
        for (let i = 0; i < keywords.length; i++) {
            let keywordContent = keywords[i].substring(0, keywords[i].indexOf('(')).replace(/\s/g, '');
            keywordContent = specialExceptions(keywordContent);
            if (levenshteinDistance(lobs, keywordContent) < 5 || lobs.includes(keywordContent)) {
                possibilities.push(keywords[i]);
            }
        }
        let lowest = 99;
        let mostLikelyMatch = "";
        //Compare possible matches
        for (let i = 0; i < possibilities.length; i++) {
            let keywordContent = possibilities[i].substring(0, possibilities[i].indexOf('(')).replace(/\s/g, '');
            let lev = levenshteinDistance(lobs, keywordContent);
            if (lev < lowest) {
                mostLikelyMatch = possibilities[i];
                lowest = lev;
            }
        }
        if (mostLikelyMatch.length > 1) {
            return mostLikelyMatch;
        }
        return "None";
    }

    function micColor(color, filter) {
        document.getElementById('requestButton').style.borderColor = color;
        document.getElementById('requestButtonImage').style.filter = filter;
    }

    // new instance of speech recognition
    var recognition = new webkitSpeechRecognition();
    var recognizerRun = false;

    let previousCommand = "";
    //Recognition Service
    function RecognizeVoice() {
        //Turning recognizer off and on
        if (recognizerRun) {
            micColor("white", '');
            recognizerRun = false;
            recognition.stop();
            return;
        }
        micColor("red", 'brightness(0.5) sepia(1) hue-rotate(345deg) saturate(100)');

        //Initialization
        recognition.lang = 'fi-FI';
        recognition.continuous = true;
        recognition.maxAlternatives = 3;
        recognition.interimResults = true;
        recognizerRun = true;
        recognition.start();

        //Results we have to check for
        // 47 1 poisto
        // 471 poisto
        // 4 71 poisto
        // 47 1poisto
        // 4711 osto
        // 47.01 poisto
        // 471 poistotuote
        recognition.onresult = function (event) {
            IndicatorColor("red");
            
            var resultsLength = event.results.length - 1;
            var ArrayLength = event.results[resultsLength].length - 1;
            var transcription = "";
            let lastWords = event.results[resultsLength][0].transcript;
            let tempSegments = event.results[resultsLength][0].transcript.split(' ');

            //Limit recognition preview to 4 words.
            if(tempSegments.length > 4) {
                let len = tempSegments.length;
                lastWords = `${tempSegments[len - 4]} ${tempSegments[len - 3]} ${tempSegments[len - 2]} ${tempSegments[len - 1]}`;
            }
            UpdateState(lastWords);

            //We only want to compare the final result
            if (!event.results[resultsLength].isFinal) { return; }
            console.log(event.results);

            //Retrieve all transcriptions
            for (let i = 0; i <= ArrayLength; i++) {
                transcription += event.results[resultsLength][i].transcript + ' ';
            }
            let segments = transcription.split(' ');
            Recognize(segments);
        }

        //Recognition needs to be continuous
        recognition.onend = function (event) {
            console.log('Speech recognition service disconnected');
            if (recognizerRun) {
                recognition.start();
            }
        }

        // speech error handling
        recognition.onerror = function (event) {
            console.log('error?');
            console.log(event);
            if (recognizerRun) {
                recognition.start();
            }
        }
    }

    function Recognize(segments) {
        //Retrieving observation
        if (segments.length >= 2) {
            var observation = "None";
            var numbers = "";
            var surface = "";
            for (let i = 0; i < segments.length; i++) {
                if (!isNaN(segments[i])) { continue; }

                if (observation == "None" && i + 3 < segments.length) { observation = ApproximateKeyword(segments[i] + segments[i + 1] + segments[i + 2] + segments[i + 3]); }
                if (observation == "None" && i + 2 < segments.length) { observation = ApproximateKeyword(segments[i] + segments[i + 1] + segments[i + 2]); }
                if (observation == "None" && i + 1 < segments.length) { observation = ApproximateKeyword(segments[i] + segments[i + 1]); }
                if (observation == "None") { observation = ApproximateKeyword(segments[i]); }

                if (observation != "None") {
                    if (i == 0) { break; }
                    numbers = segments[i - 1].replace('.', '').replace('0', '');
                    if (isNaN(segments[i - 1])) { return; }
                    //Filter out: 40 15 poisto
                    if (i - 2 >= 0) {
                        if (numbers.length < 2 || segments[i - 2].includes('0')) {
                            numbers = (segments[i - 2] + segments[i - 1]).replace('0', '');
                        }
                    }
                    break;
                }
            }
            if (observation == "None") { return; }
            // Result is in format 4711poisto
            if (numbers.length == 4) {
                numbers = numbers.substring(0, 3);
            }
            // Result is in format 471poisto
            if (numbers.length == 3) {
                surface = numbers.substring(2);
                numbers = numbers.substring(0, 2);
            }

            IndicatorColor("blue");
            UpdateState(observation);
            //Result does not have a valid number
            if (isNaN(numbers) || numbers.length != 2) { return; }
            //Surface specific observation made on a tooth
            if (surface.length < 1 && surfaceKeywords.includes(observation)) { IndicatorColor("yellow"); return; }
            //Tooth specific observation made on a surface
            if (surface.length == 1 && toothKeywords.includes(observation)) { IndicatorColor("yellow"); return; }

            //Result has passed all restrictions
            IndicatorColor("green");

            let toothNum = numbers;
            let command = `${toothNum} ${surface} ${observation}`;
            UpdateState(command);

            if (command != previousCommand) {
                if (toothNotFound(toothNum)) {
                    Speech("Hammasta ei löytynyt");
                    IndicatorColor("yellow");
                    return;
                }
                InitiateCommand(toothNum, surface, observation, true);
                previousCommand = command;
                Speech(command);
            }
        }
    }



</script>

